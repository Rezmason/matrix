<html>
<head>
  <title>Matrix digital rain</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body style="height: 100vh; margin: 0; overflow: hidden; position: fixed; padding: 0; width: 100vw;">
  <script src="./lib/three.js"></script>

  <script src="./js/CopyShader.js"></script>

  <script src="./js/EffectComposer.js"></script>
  <script src="./js/RenderPass.js"></script>
  <script src="./js/ShaderPass.js"></script>

  <script src="./js/ColorMapPass.js"></script>
  <script src="./js/HorizontalColorationPass.js"></script>
  <script src="./js/LuminosityHighPassShader.js"></script>
  <script src="./js/UnrealBloomPass.js"></script>
  <script src="./js/ImageOverlayPass.js"></script>
  <script src="./js/GPUComputationRenderer.js"></script>

  <script src="./js/MatrixRenderer.js"></script>

  <script>

    const urlParams = new Map(window.location.href.replace(/^[^\?]+\?/, "").split("&").map(pair => pair.split("=")));
    const getParam = (key, defaultValue) => urlParams.has(key) ? urlParams.get(key) : defaultValue;

    const sharpness = parseFloat(getParam("sharpness", 0.5));
    const animationSpeed = parseFloat(getParam("animationSpeed", 1));
    const fallSpeed = parseFloat(getParam("fallSpeed", 1));
    const cycleSpeed = parseFloat(getParam("cycleSpeed", 1));
    const numColumns = parseInt(getParam("width", 80));
    const glyphSequenceLength = 57;
    const numGlyphColumns = 8;

    const effect = getParam("effect", "plain");

    document.ontouchmove = (e) => e.preventDefault();
    const element = document.createElement("matrixcode");
    document.body.appendChild(element);
    const renderer = new THREE.WebGLRenderer({ stencil: false, depth: false, precision: "lowp" });
    renderer.sortObjects = true;
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( window.innerWidth, window.innerHeight );
    element.appendChild(renderer.domElement);
    const composer = new THREE.EffectComposer( renderer );

    const texture = new THREE.TextureLoader().load( './matrixcode_msdf.png' );

    const matrixRenderer = makeMatrixRenderer(renderer, texture, {
      sharpness,
      numColumns,
      animationSpeed, fallSpeed, cycleSpeed,
      glyphSequenceLength,
      numGlyphColumns
    });

    matrixRenderer.pass.renderToScreen = false;
    composer.addPass( matrixRenderer.pass );

    const bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 2, 0.5, 0.3 );
    composer.addPass( bloomPass );

    switch (effect) {
      case "plain":
        composer.addPass(new THREE.ColorMapPass([
          {color: new THREE.Vector3(0.00, 0.00, 0.00), at: 0.0},
          {color: new THREE.Vector3(0.05, 0.52, 0.17), at: 0.4},
          {color: new THREE.Vector3(0.12, 0.82, 0.37), at: 0.8},
          {color: new THREE.Vector3(0.29, 1.00, 0.64), at: 1.0},
        ], 0.1));
        break;
      case "pride":
        composer.addPass(new THREE.HorizontalColorationPass([
          new THREE.Vector3(1, 0, 0),
          new THREE.Vector3(1, 0.5, 0),
          new THREE.Vector3(1, 1, 0),
          new THREE.Vector3(0, 1, 0),
          new THREE.Vector3(0, 0, 1),
          new THREE.Vector3(0.8, 0, 1),
        ], 0.1));
        break;
      case "customStripes":
        const flagColorData = getParam("colors", "0.4,0.15,0.1,0.4,0.15,0.1,0.8,0.8,0.6,0.8,0.8,0.6,1.0,0.7,0.8,1.0,0.7,0.8,").split(",").map(parseFloat);
        const numFlagColors = Math.floor(flagColorData.length / 3);
        const colors = [];
        for (let i = 0; i < numFlagColors; i++) {
          colors.push(new THREE.Vector3(flagColorData[i * 3 + 0], flagColorData[i * 3 + 1], flagColorData[i * 3 + 2]));
        }
        composer.addPass(new THREE.HorizontalColorationPass(colors, 0.1));
        break;
      case "none":
        break;
      case "image":
        const imageURL = getParam("url", "https://upload.wikimedia.org/wikipedia/commons/0/0a/Flammarion_Colored.jpg");
        window.texture2 = new THREE.TextureLoader().load( imageURL );
        composer.addPass(new THREE.ImageOverlayPass(texture2));
        break;
    }

    composer.passes[composer.passes.length - 1].renderToScreen = true;

    const windowResize = () => {
      const [width, height] = [window.innerWidth, window.innerHeight];
      renderer.setSize(width, height);
      matrixRenderer.resize(width, height);
      bloomPass.setSize( window.innerWidth, window.innerHeight );
    }
    window.addEventListener("resize", windowResize, false);
    window.addEventListener("orientationchange", windowResize, false);
    windowResize();

    const render = () => {
      requestAnimationFrame(render);
      matrixRenderer.render();
      composer.render();
    }
    render();

  </script>
</body></html>
